import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import {  Accelerometer, Gyroscope, Magnetometer } from 'expo-sensors';
import simpleStatistics from 'simple-statistics';
import axios from 'axios';

export default function SensorData() {
  const [accelerometerData, setAccelerometerData] = useState(null);
  const [gyroscopeData, setGyroscopeData] = useState(null);
  const [magnetometerData, setMagnetometerData] = useState(null);
  const [dataHistory, setDataHistory] = useState([]);
  const [capturing, setCapturing] = useState(true);
  const [accMax, setAccMax] = useState(null);
  const [accKurtosis, setAccKurtosis] = useState(null);
  const [accSkewness, setAccSkewness] = useState(null);
  const [gyroMax, setGyroMax] = useState(null);
  const [gyroKurtosis, setGyroKurtosis] = useState(null);
  const [gyroSkewness, setGyroSkewness] = useState(null);
  const [magMax, setMagMax] = useState(null);
  const [magKurtosis, setMagKurtosis] = useState(null);
  const [magSkewness, setMagSkewness] = useState(null);
  const linMaxInterval = 4000;  // Intervalo de 4 segundos para linMaxValue
  const postLinMaxInterval = 6000;  // Intervalo de 6 segundos para postLinMaxValue, postGyroMaxValue y postMagMaxValue
  const captureInterval = 6000; // 6 segundos
  const pauseInterval = 3000; // 3 segundos
  const [timer, setTimer] = useState(null);

  // Crear una función para enviar los datos al servidor
  const sendDataToServer = async (jsonData) => {
    try {
      const response = await axios.post('http://172.16.128.101:3000/data/sensors', jsonData);
      console.log('Respuesta del servidor:', response.data);
    } catch (error) {
      console.error('Error al enviar datos al servidor:', error);
    }
  };

  const captureData = () => {
    const interval = capturing ? captureInterval : pauseInterval;
    const timerId = setInterval(() => {
      if (capturing) {
        processAndSendData(); // Procesa y envía datos después del intervalo de captura
        startCapturingData(); // Reinicia la captura
      } else {
        stopCapturingData();
      }
    }, interval);
    setTimer(timerId);
  };
  const startCapturingData = () => {
    setCapturing(true);
    captureData();
  };
  
  const stopCapturingData = () => {
    setCapturing(false);
    clearTimeout(timer);
    // Comienza la captura nuevamente después de un intervalo de pausa
    setTimeout(() => {
      startCapturingData();
    }, pauseInterval);
  };
  //Limpia el temporizador cuando el componente se desmonta
  useEffect(() => {
    startCapturingData();
    return () => {
      clearTimeout(timer);
    };
  }, []);
  
  useEffect(() => {
    let isCapturing = true;
    let accSubscription, gyroSubscription, magSubscription;

    const startCapturingData = () => {
      if (isCapturing) {
        accSubscription = Accelerometer.addListener((data) => {
          setAccelerometerData(data);
          setDataHistory((prevData) => [...prevData, { type: 'accelerometer', data, timestamp: new Date() }]);
        });

        gyroSubscription = Gyroscope.addListener((data) => {
          setGyroscopeData(data);
          setDataHistory((prevData) => [...prevData, { type: 'gyroscope', data, timestamp: new Date() }]);
        });

        magSubscription = Magnetometer.addListener((data) => {
          setMagnetometerData(data);
          setDataHistory((prevData) => [...prevData, { type: 'magnetometer', data, timestamp: new Date() }]);
        });

        setTimeout(() => {
          stopCapturingData();
        }, 6000);
      }
    };

    const stopCapturingData = () => {
      isCapturing = false;
      accSubscription.remove();
      gyroSubscription.remove();
      magSubscription.remove();
      setCapturing(false);
    };

    startCapturingData();

    return () => {
      stopCapturingData();
    };
  }, []);
  

// Función para procesar y enviar datos
const processAndSendData = (datosentrada, currentTime) => {
  const accData = dataHistory
  .filter((entry) => entry.type === 'accelerometer')
  .map((entry) => entry.data.x);

const gyroData = dataHistory
  .filter((entry) => entry.type === 'gyroscope')
  .map((entry) => entry.data.x);

const magData = dataHistory
  .filter((entry) => entry.type === 'magnetometer')
  .map((entry) => entry.data.x);

// Calcular la curtosis, máx y skewness de los datos del acelerómetro
const n = accData.length;

const datos = datosentrada.filter((dato) => dato.timestamp >= 0 && dato.timestamp < 7);
const ventanaDatosCuartoSegundo = datos.filter((dato) => dato.timestamp >= 4 && dato.timestamp < 5);

// Calcula las magnitudes de los sensores
const magnitudesAceleracion = [];
for (const dato of ventanaDatosCuartoSegundo) {
  const magnitud = calcularMagnitud({ x: dato.acc_x, y: dato.acc_y, z: dato.acc_z });
  magnitudesAceleracion.push(magnitud);
}

const magnitudesGiroscopio = [];
for (const dato of ventanaDatosCuartoSegundo) {
  const magnitud = calcularMagnitud({ x: dato.gyro_x, y: dato.gyro_y, z: dato.gyro_z });
  magnitudesGiroscopio.push(magnitud);
}

const magnitudesMagnetometro = [];
for (const dato of ventanaDatosCuartoSegundo) {
  const magnitud = calcularMagnitud({ x: dato.mag_x, y: dato.mag_y, z: dato.mag_z });
  magnitudesMagnetometro.push(magnitud);
}

// Calcula métricas basadas en las magnitudes
const acc_max = Math.max(...magnitudesAceleracion);
const acc_kurtosis = calcularCurtosis(magnitudesAceleracion);
const acc_skewness = calcularAsimetria(magnitudesAceleracion);

const gyro_max = Math.max(...magnitudesGiroscopio);
const gyro_kurtosis = calcularCurtosis(magnitudesGiroscopio);
const gyro_skewness = calcularAsimetria(magnitudesGiroscopio);

const mag_max = Math.max(...magnitudesMagnetometro);
const mag_curtosis = calcularCurtosis(magnitudesMagnetometro);
const mag_skewness = calcularAsimetria(magnitudesMagnetometro);





// Calcular las métricas para el acelerómetro
/*const meanAcc = accData.reduce((acc, value) => acc + value, 0) / n;
const fourthMomentAcc = accData.reduce((acc, value) => acc + Math.pow(value - meanAcc, 4), 0) / n;
const varianceAcc = accData.reduce((acc, value) => acc + Math.pow(value - meanAcc, 2), 0) / n;
const kurtosisAcc = fourthMomentAcc / (varianceAcc * varianceAcc);
setAccKurtosis(kurtosisAcc);*/

// Calcular las métricas para el magnetómetro
/*const meanMag = magData.reduce((acc, value) => acc + value, 0) / nMag;
const fourthMomentMag = magData.reduce((acc, value) => acc + Math.pow(value - meanMag, 4), 0) / nMag;
const varianceMag = magData.reduce((acc, value) => acc + Math.pow(value - meanMag, 2), 0) / nMag;
const kurtosisMag = fourthMomentMag / (varianceMag * varianceMag);
setMagKurtosis(kurtosisMag);*/

// Calcular las métricas para el giroscopio
/*const meanGyro = gyroData.reduce((acc, value) => acc + value, 0) / nGyro;
const fourthMomentGyro = gyroData.reduce((acc, value) => acc + Math.pow(value - meanGyro, 4), 0) / nGyro;
const varianceGyro = gyroData.reduce((acc, value) => acc + Math.pow(value - meanGyro, 2), 0) / nGyro;
const kurtosisGyro = fourthMomentGyro / (varianceGyro * varianceGyro);
setGyroKurtosis(kurtosisGyro);*/

//const linMaxData = getMetricData(dataHistory, 'accelerometer', linMaxInterval, currentTime);
//const postLinMaxData = getMetricData(dataHistory, 'accelerometer', postLinMaxInterval, currentTime);
//const postGyroMaxData = getMetricData(dataHistory, 'gyroscope', postLinMaxInterval, currentTime);
//const postMagMaxData = getMetricData(dataHistory, 'magnetometer', postLinMaxInterval, currentTime);

// Calcular linMaxValue, postLinMaxValue, postGyroMaxValue y postMagMaxValue
//const linMaxValue = linMaxData ? Math.max(...linMaxData.map((entry) => entry.data.x)) : null;
//const postLinMaxValue = postLinMaxData ? Math.max(...postLinMaxData.map((entry) => entry.data.x)) : null;
//const postGyroMaxValue = postGyroMaxData ? Math.max(...postGyroMaxData.map((entry) => entry.data.x)) : null;
//const postMagMaxValue = postMagMaxData ? Math.max(...postMagMaxData.map((entry) => entry.data.x)) : null;

//const skewnessAcc = accData.length >= 3 ? simpleStatistics.sampleSkewness(accData) : null;
//setAccSkewness(skewnessAcc);

//const skewnessGyro = simpleStatistics.sampleSkewness(gyroData);
//setGyroSkewness(skewnessGyro);

//const skewnessMag = simpleStatistics.sampleSkewness(magData);
//setMagSkewness(skewnessMag);

//Calculo de Kutorsis para los tres sensores
const kurtosisAcc = calcularCurtosis(accData);
setAccKurtosis(kurtosisAcc);

const kurtosisMag = calcularCurtosis(magData);
setMagKurtosis(kurtosisMag);

const kurtosisGyro = calcularCurtosis(gyroData);
setGyroKurtosis(kurtosisGyro);

//Calculo de linMaxValue, postLinMaxValue, postGyroMaxValue y postMagMaxValue
const linMaxData  = dataHistory.filter((entry) => entry.type === 'accelerometer');
const linMaxValue = calcularLinMax(linMaxData );

const postLinMaxData  = dataHistory.filter((entry) => entry.type === 'accelerometer');
const postLinMaxValue = calcularPostLinMax(postLinMaxData);

const postGyroMaxData = dataHistory.filter((entry) => entry.type === 'gyroscope');
const postGyroMaxValue = calcularPostGyroMax(postGyroMaxData);

const postMagMaxData = dataHistory.filter((entry) => entry.type === 'magnetometer');
const postMagMaxValue = calcularPostMagMax(postMagMaxData);

//Calcular de asimetría de acelerómetro, giroscopio y magnetómetro
const skewnessAcc = accData.length >= 3 ? calcularAsimetria(accData) : null;
setAccSkewness(skewnessAcc);

const skewnessGyro = gyroData.length >= 3 ? calcularAsimetria(gyroData) : null;
setGyroSkewness(skewnessGyro);

const skewnessMag = magData.length >= 3 ? calcularAsimetria(magData) : null;
setMagSkewness(skewnessMag);


const maxAcc = Math.max(...accData);
setAccMax(maxAcc);

//const skewnessAcc = simpleStatistics.sampleSkewness(accData);
//setAccSkewness(skewnessAcc);

// Filtrar datos del giroscopio
const nGyro = gyroData.length;

const maxGyro = Math.max(...gyroData);
setGyroMax(maxGyro);

// Filtrar datos del magnetómetro
const nMag = magData.length;

const maxMag = Math.max(...magData);
setMagMax(maxMag);

// Obtener datos específicos para los intervalos de tiempo
const currentTime = new Date();


//se guardan los datos en un json
const jsonData = {
  'acc_max': maxAcc,
  'acc_kurtosis': kurtosisAcc,
  'acc_skewness': skewnessAcc,
  'gyro_max': maxGyro,
  'gyro_kurtosis': kurtosisGyro,
  'gyro_skewness': skewnessGyro,
  'linMaxValue': linMaxValue,
  'postLinMaxValue': postLinMaxValue,
  'postGyroMaxValue': postGyroMaxValue,
  'postMagMaxValue': postMagMaxValue,
  'mag_max': maxMag,
  'mag_curtosis': kurtosisMag,
  'mag_skewness': skewnessMag,
};

//Imprimir el objeto JSON en la consola
console.log('JSON Data:', JSON.stringify(jsonData, null, 2));

// Enviar el objeto JSON al servidor 
sendDataToServer(jsonData);
};

  //hace los calculos y envia
useEffect(() => {
    if (!capturing) {
      // Filtrar datos de acelerómetro, giroscopio y magnetómetro
      processAndSendData();
    }
  }, [capturing, dataHistory]);

// Función para obtener datos específicos en un intervalo de tiempo
const getMetricData = (data, type, interval, currentTime) => {
    const intervalStart = new Date(currentTime - interval);
    return data
      .filter((entry) => entry.type === type && entry.timestamp >= intervalStart && entry.timestamp <= currentTime);
};

//Funcion para calcular magnitud
const calcularMagnitud=(vector)=> {
  return Math.sqrt(vector.x ** 2 + vector.y **2 + vector.z ** 2);
}

// Función para calcular la curtosis de un conjunto de datos
const calcularCurtosis=(datos)=>{
  const n = datos.length;
  const media = datos.reduce((sum, val) => sum + val, 0) / n;
  const sumatoria4 = datos.reduce((sum, val) => sum + Math.pow(val - media, 4), 0);
  const desviacionEstandar = Math.sqrt(sumatoria4 / n);
  const curtosis = sumatoria4 / (n * Math.pow(desviacionEstandar, 4))-3;
  return curtosis;
}

// Función para calcular la asimetría de un conjunto de datos
const calcularAsimetria=(datos)=>{
  const n = datos.length;
  const media = datos.reduce((sum, val) => sum + val, 0) / n;
  const sumatoria3 = datos.reduce((sum, val) => sum + Math.pow(val - media, 3), 0);
  const desviacionEstandar = Math.sqrt(datos.reduce((sum, val) => sum + Math.pow(val - media, 2), 0) / n);
  const asimetria = sumatoria3 / (n * Math.pow(desviacionEstandar, 3));
  return asimetria;
}

const calcularLinMax=(datos)=>{
  const gravedad = 9.81; // Valor aproximado de la gravedad en m/s²
  let lin_max = 0; // Inicializar en 0
  for (const fila of datos) {
    const acc_magnitud = this.calcularMagnitud({
      x: fila.acc_x,
      y: fila.acc_y,
      z: fila.acc_z
    });
    // Excluir la gravedad restando el valor estimado de gravedad
    const acc_excluyendo_gravedad = Math.max(0, acc_magnitud - gravedad);
    // Para calcular lin_max (Máxima aceleración lineal en el 4to segundo) excluyendo la gravedad
    if (fila.timestamp >= 4 && fila.timestamp < 5) {
      if (acc_excluyendo_gravedad > lin_max) {
        lin_max = acc_excluyendo_gravedad;
      }
    }
  }
  return lin_max;
}

// Función para calcular post_lin_max
const calcularPostLinMax=(datos)=> {
  let post_lin_max = 0; // Inicializar en 0
  for (const fila of datos) {
    const acc_magnitud = this.calcularMagnitud({
      x: fila.acc_x,
      y: fila.acc_y,
      z: fila.acc_z
    });
  // Para calcular post_lin_max (Máxima aceleración lineal en el 6to segundo)
    if (fila.timestamp >= 6 && fila.timestamp < 7) {
      if (acc_magnitud > post_lin_max) {
      post_lin_max = acc_magnitud;
      }
    }
  }
  return post_lin_max;
}

// Función para calcular post_gyro_max
const calcularPostGyroMax=(datos)=> {
  let post_gyro_max = 0; // Inicializar en 0
  for (const fila of datos) {
    const gyro_magnitud = this.calcularMagnitud({
      x: fila.gyro_x,
      y: fila.gyro_y,
      z: fila.gyro_z
    });
    // Para calcular post_gyro_max (Máxima magnitud del giroscopio en el 6to segundo)
    if (fila.timestamp >= 6 && fila.timestamp < 7) {
      if (gyro_magnitud > post_gyro_max) {
        post_gyro_max = gyro_magnitud;
      }
    }
  }
  return post_gyro_max;
}

// Función para calcular post_mag_max
const calcularPostMagMax=(datos)=>{
  let post_mag_max = 0; // Inicializar en 0
  for (const fila of datos) {
    const mag_magnitud = this.calcularMagnitud({
      x: fila.mag_x,
      y: fila.mag_y,
      z: fila.mag_z
    });
    // Para calcular post_gyro_max (Máxima magnitud del giroscopio en el 6to segundo)
    if (fila.timestamp >= 6 && fila.timestamp < 7) {
      if (mag_magnitud > post_mag_max) {
        post_mag_max = mag_magnitud;
      }
    }
  }
  return post_mag_max;
}



  return (
    <View style={styles.container}>
      <Text>Acelerómetro Data:</Text>
      {accelerometerData && (
        <View>
          <Text>X: {accelerometerData.x.toFixed(15)}</Text>
          <Text>Y: {accelerometerData.y.toFixed(15)}</Text>
          <Text>Z: {accelerometerData.z.toFixed(15)}</Text>
        </View>
      )}
      <Text>Giroscopio Data:</Text>
      {gyroscopeData && (
        <View>
          <Text>X: {gyroscopeData.x.toFixed(15)}</Text>
          <Text>Y: {gyroscopeData.y.toFixed(15)}</Text>
          <Text>Z: {gyroscopeData.z.toFixed(15)}</Text>
        </View>
      )}
      <Text>Magnetómetro Data:</Text>
      {magnetometerData && (
        <View>
          <Text>X: {magnetometerData.x.toFixed(15)}</Text>
          <Text>Y: {magnetometerData.y.toFixed(15)}</Text>
          <Text>Z: {magnetometerData.z.toFixed(15)}</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  text: {
    textAlign: 'center',
  },
});









import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Accelerometer, Gyroscope, Magnetometer } from 'expo-sensors';
import axios from 'axios';
import Calculador from './Calculador2';

export default function SensorData() {
  const [accelerometerData, setAccelerometerData] = useState(null);
  const [gyroscopeData, setGyroscopeData] = useState(null);
  const [magnetometerData, setMagnetometerData] = useState(null);
  const [dataHistory, setDataHistory] = useState([]);
  const [capturing, setCapturing] = useState(true);
  const captureInterval = 6000; // 6 segundos
  const pauseInterval = 5000; // 3 segundos
  const accelerometerSubscription = useRef(null);
  const gyroscopeSubscription = useRef(null);
  const magnetometerSubscription = useRef(null);

  // Crear una función para enviar los datos al servidor
  const sendDataToServer = async (jsonData) => {
    try {
      const response = await axios.post('http://172.16.128.102:3000/data/sensors', jsonData);
      console.log('Respuesta del servidor:', response.data);
    } catch (error) {
      console.error('Error al enviar datos al servidor:', error);
    }
  };

  useEffect(() => {
    let isCapturing = true;
    let captureIntervalId;
  
    const startCapturingData = () => {
      let accSubscription, gyroSubscription, magSubscription;
  
      accSubscription = Accelerometer.addListener((data) => {
        console.log('Accelerometer Data:', data);
        setAccelerometerData(data);
        setDataHistory((prevData) => [...prevData, { type: 'accelerometer', data, timestamp: new Date() }]);
      });
  
      gyroSubscription = Gyroscope.addListener((data) => {
        console.log('Gyroscopyo Data:', data);
        setGyroscopeData(data);
        setDataHistory((prevData) => [...prevData, { type: 'gyroscope', data, timestamp: new Date() }]);
      });
  
      magSubscription = Magnetometer.addListener((data) => {
        console.log('Magnetometro Data:', data);
        setMagnetometerData(data);
        setDataHistory((prevData) => [...prevData, { type: 'magnetometer', data, timestamp: new Date() }]);
      });
  
      // Iniciar el intervalo de captura
      captureIntervalId = setInterval(() => {
        stopCapturingData();
      }, captureInterval);
    };
  
    const stopCapturingData = () => {
      // Detener la captura y limpiar suscripciones
      isCapturing = false;
      if (accSubscription) accSubscription.remove();
      if (gyroSubscription) gyroSubscription.remove();
      if (magSubscription) magSubscription.remove();
      setCapturing(false);
  
      // Detener el intervalo
      clearInterval(captureIntervalId);
  
      // Procesar y enviar datos
      processAndSendData();
    };
  
    // Iniciar la captura al montar el componente
    startCapturingData();
  
    // Limpiar suscripciones al desmontar el componente
    return () => {
      stopCapturingData();
    };
  }, []);


  // Función para procesar y enviar datos
  const processAndSendData = () => {
    if (dataHistory.length === 0) {
      console.log('No hay datos en el historial para procesar.');
      return;
    }

    const calculador = new Calculador();
    const campos = calculador.calcularCaracteristicas(dataHistory);

    if (!campos || campos.length !== 13) {
      console.error('Error al calcular características. Campos incorrectos:', campos);
      return;
    }

    // Se guardan los datos en un objeto JSON
    const jsonData = {
      'acc_max': campos[0],
      'acc_kurtosis': campos[1],
      'acc_skewness': campos[2],
      'gyro_max': campos[3],
      'gyro_kurtosis': campos[4],
      'gyro_skewness': campos[5],
      'linMaxValue': campos[6],
      'postLinMaxValue': campos[7],
      'postGyroMaxValue': campos[8],
      'postMagMaxValue': campos[9],
      'mag_max': campos[10],
      'mag_curtosis': campos[11],
      'mag_skewness': campos[12],
    };

    // Imprimir el objeto JSON en la consola
    console.log('JSON Data:', JSON.stringify(jsonData, null, 2));
    console.log('JSON Data:', jsonData);
    // Enviar el objeto JSON al servidor
    sendDataToServer(jsonData);
  };
  return (
    <View style={styles.container}>
      <Text>Acelerómetro Data:</Text>
      {accelerometerData && (
        <View>
          <Text>X: {accelerometerData.x.toFixed(15)}</Text>
          <Text>Y: {accelerometerData.y.toFixed(15)}</Text>
          <Text>Z: {accelerometerData.z.toFixed(15)}</Text>
        </View>
      )}
      <Text>Giroscopio Data:</Text>
      {gyroscopeData && (
        <View>
          <Text>X: {gyroscopeData.x.toFixed(15)}</Text>
          <Text>Y: {gyroscopeData.y.toFixed(15)}</Text>
          <Text>Z: {gyroscopeData.z.toFixed(15)}</Text>
        </View>
      )}
      <Text>Magnetómetro Data:</Text>
      {magnetometerData && (
        <View>
          <Text>X: {magnetometerData.x.toFixed(15)}</Text>
          <Text>Y: {magnetometerData.y.toFixed(15)}</Text>
          <Text>Z: {magnetometerData.z.toFixed(15)}</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  text: {
    textAlign: 'center',
  },
});













El que va_

import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Accelerometer, Gyroscope, Magnetometer } from 'expo-sensors';

export default function SensorData() {
  const [sensorData, setSensorData] = useState([]);
  const [isPaused, setIsPaused] = useState(false);
  const accelerometerDataRef = useRef(null);
  const gyroscopeDataRef = useRef(null);
  const magnetometerDataRef = useRef(null);

  useEffect(() => {
    let isMounted = true;

    const startCapturingData = async () => {
      while (isMounted) {
        const dataHistory = [];
        await new Promise(resolve => {
          let timeout = setTimeout(() => {
            clearTimeout(timeout);
            resolve();
          }, 6000);

          const accSubscription = Accelerometer.addListener(data => {
            accelerometerDataRef.current = data;
            dataHistory.push({ type: 'accelerometer', data, timestamp: new Date() });
          });

          const gyroSubscription = Gyroscope.addListener(data => {
            gyroscopeDataRef.current = data;
            dataHistory.push({ type: 'gyroscope', data, timestamp: new Date() });
          });

          const magSubscription = Magnetometer.addListener(data => {
            magnetometerDataRef.current = data;
            dataHistory.push({ type: 'magnetometer', data, timestamp: new Date() });
          });

          // Captura por 6 segundos
          setTimeout(() => {
            accSubscription.remove();
            gyroSubscription.remove();
            magSubscription.remove();
            resolve();
          }, 6000);
        });

        if (isMounted) {
          // Almacena todos los datos capturados y ordenados por tiempo
          setSensorData(prevData => [...prevData, ...dataHistory.sort((a, b) => a.timestamp - b.timestamp)]);

          // Pausa durante 10 segundos
          setIsPaused(true);
          console.log('Estoy pausado');
          await new Promise(resolve => setTimeout(resolve, 10000));
          setIsPaused(false);
        }
      }
    };

    startCapturingData();

    return () => {
      isMounted = false;
    };
  }, []);

  // Este useEffect se ejecutará cuando sensorData cambie
  useEffect(() => {
    console.log('Todos los datos ordenados por tiempo:', sensorData);
  }, [sensorData]);

  return (
    <View style={styles.container}>
      <Text>Acelerómetro Data:</Text>
      {accelerometerDataRef.current && (
        <View>
          <Text>X: {accelerometerDataRef.current.x?.toFixed(15)}</Text>
          <Text>Y: {accelerometerDataRef.current.y?.toFixed(15)}</Text>
          <Text>Z: {accelerometerDataRef.current.z?.toFixed(15)}</Text>
        </View>
      )}
      <Text>Giroscopio Data:</Text>
      {gyroscopeDataRef.current && (
        <View>
          <Text>X: {gyroscopeDataRef.current.x?.toFixed(15)}</Text>
          <Text>Y: {gyroscopeDataRef.current.y?.toFixed(15)}</Text>
          <Text>Z: {gyroscopeDataRef.current.z?.toFixed(15)}</Text>
        </View>
      )}
      <Text>Magnetómetro Data:</Text>
      {magnetometerDataRef.current && (
        <View>
          <Text>X: {magnetometerDataRef.current.x?.toFixed(15)}</Text>
          <Text>Y: {magnetometerDataRef.current.y?.toFixed(15)}</Text>
          <Text>Z: {magnetometerDataRef.current.z?.toFixed(15)}</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  text: {
    textAlign: 'center',
  },
});
